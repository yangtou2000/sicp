(define nil '())
(define (append iterms1 iterms2)
    (if (null? iterms1)
        iterms2
        (cons (car iterms1) (append (cdr iterms1) iterms2))))
(define (reverse items)
    (define (reverse-iter items list)
        (if (null? items)
            list
            (reverse-iter (cdr items) (cons (car items) list))))
    (reverse-iter items '()))

(define (deep-reverse items)
    (define (deep-reverse-iter items list)
        (cond ((null? items) list)
	      ((not (pair? (car items))) (deep-reverse-iter (cdr items) (cons (car items) list)))
	      (else (deep-reverse-iter (cdr items) (cons (deep-reverse-iter (car items) nil) list)))))
    (deep-reverse-iter items nil))

(define (map proc items)
	(if (null? items)
	    nil
            (cons (proc (car items)) (map proc (cdr items)))))
(define (for-each proc items)        
        (if (null? items)
            nil
            (let () 
                 (proc (car items))
                 (for-each proc (cdr items)))))
(define (tree-map proc tree)
        (cond ((null? tree) nil)
              ((not (pair? (car tree))) (cons (proc (car tree)) (tree-map proc (cdr tree))))
              (else (cons (tree-map proc (car tree))(tree-map proc (cdr tree))))))

(define (fringe tree)
        (cond ((null? tree) nil)
              ((not (pair? (car tree))) (cons (car tree) (fringe (cdr tree))))
              (else (append (fringe (car tree)) (fringe (cdr tree))))))

(define (filter predicate sequence)
        (cond ((null? sequence) nil)
              ((predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence))))
              (else (filter predicate (cdr sequence)))))
(define (fold-right op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence) (fold-right op initial (cdr sequence)))))
(define (fold-left op initial sequence)
        (if (null? sequence)
            initial
            (fold-left op (op initial (car sequence)) (cdr sequence))))
(define accumulate fold-right)
(define enumerate-tree  fringe)
(define (map-2 p sequence)
        (accumulate (lambda (x y) (cons (p x) y)) nil sequence))
(define (append-2 seq1 seq2)
        (accumulate cons seq1 seq2))
(define (length sequence)
        (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
(define (horner-evel x coefficient-sequence)
        (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
                     0
                     coefficient-sequence))
(define (count-leaves t)
        (cond ((null? t) 0)
              ((not (pair? t)) 1)
              (else (+ (count-leaves (car t)) (count-leaves (cdr t))))))
(define (count-leaves-2 t)
        (accumulate (lambda (leaves total) (+ leaves total))
                    0
                    (map (lambda (sub-tree)  (if (not (pair? sub-tree)) 1 (count-leaves-2 sub-tree))) t)))
(define (subsets s)
        (if (null? s)
            (list nil)
            (let ((rest (subsets (cdr s))))
               (append rest (map (lambda (sub-set) (cons (car s) sub-set)) rest)))))
(define (flatmap proc seq)
        (accumulate append nil (map proc seq)))

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)